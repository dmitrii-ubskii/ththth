(define (err? x)
  (eq? x 'ERR))

(define (list . args)
  args)

(define (not x)
  (if x #f #t))

(define (and . args)
  (if (nil? args)
      #t
      (if (car args)
          (apply and (cdr args))
          #f)))

(define (or . args)
  (if (nil? args)
      #f
      (if (car args)
          #t
          (apply or (cdr args)))))

(define (pair? x)
  (not (err? (cdr x))))

(define (list? x)
  (if (nil? x)
      #t
      (if (pair? x)
          (list? (cdr x))
          #f)))

(define (cadr list)
  (car (cdr list)))
(define (caddr list)
  (cadr (cdr list)))
(define (cadddr list)
  (caddr (cdr list)))

(define (length list)
  (if (nil? list)
      0
      (+ 1 (length (cdr list)))))

(define (abs x)
  (if (< x 0)
      (- x)
      x))

(define (nan? x)
  (not (= x x)))

(define (integer? x)
  (= (trunc x) x))

(define (even? x)
  (and (integer? x) (= (remainder x 2) 0)))
(define (odd? x)
  (and (integer? x) (not (even? x))))

(define (min . args)
  (if (nil? (cdr args))
      (car args)
      (let ((head (car args))
            (min-tail (apply min (cdr args))))
        (if (< head min-tail) head min-tail))))
(define (max . args)
  (if (nil? (cdr args))
      (car args)
      (let ((head (car args))
            (max-tail (apply max (cdr args))))
        (if (> head max-tail) head max-tail))))

(define (map f args)
  (if (nil? args)
      ()
      (cons (f (car args)) (map f (cdr args)))))
